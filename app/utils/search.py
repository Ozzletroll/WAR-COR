from flask import url_for
from sqlalchemy import or_, func
import editdistance
from bs4 import BeautifulSoup
import json

from app import db
from app import models


class Paginator:
    """ Paginator class to format all results for template """

    def __init__(self, data, page, per_page):
        self.data = data
        self.per_page = per_page
        self.pages = self.initialise_pages()
        self.current_page = page
        self.page = self.get_current_page(page)
        self.total_pages = len(self.pages)
        self.page_numbers = self.get_page_numbers()

    def initialise_pages(self):

        pages = []
        page_number = 1

        for index in range(0, len(self.data), self.per_page):
            new_page = Page(page_number=page_number,
                            items=self.data[index:index + self.per_page])
            pages.append(new_page)
            page_number += 1

        return pages

    def get_current_page(self, page):

        if page > len(self.pages) or page < 1:
            return None
        else:
            return self.pages[page - 1]

    def get_page_numbers(self,
                         left_edge = 2,
                         left_current = 2,
                         right_current = 4,
                         right_edge = 2):
        
        def remove_consecutive_nones(list):

            if not list:
                return[1]

            new_list = [list[0]]
            for index in range(1, len(list)):
                if list[index] is None and list[index - 1] is None:
                    continue
                new_list.append(list[index])

            return new_list
        
        page_numbers = []

        for index, page in enumerate(self.pages):
            if (index + 1 <= left_edge or 
                page.page_number > (self.total_pages - right_edge) or 
                page.page_number == self.current_page or 
                self.current_page <= page.page_number < self.current_page + right_current or 
                self.current_page - left_current <= page.page_number < self.current_page):
                page_numbers.append(page.page_number)
            else:
                page_numbers.append(None)

        return remove_consecutive_nones(page_numbers)
    
    def serialise(self, target_url, new_page_url):

        object_dict = self.__dict__
        object_dict["pages"] = [page.serialise() for page in object_dict["pages"]]
        object_dict["page"] = object_dict["page"].serialise()
        object_dict["target_url"] = target_url
        object_dict["new_page_url"] = new_page_url
        return json.dumps(object_dict)


class Page:

    def __init__(self, page_number, items):
        self.page_number = page_number
        self.items = items

    def serialise(self):
        return self.__dict__


class Result:
    """ Result object generated by SearchEngine """

    def __init__(self):
        self.relevance = 0
        self.object = None
        self.type = ""
        self.excerpt = ""
        self.matching_attributes = []
        self.matching_attributes_text = ""
        self.url = ""
        self.edit_url = ""


class SearchEngine:
    """ Search engine class for searching within a campaign from the Advanced Search page.

            Parameters:
            --------------------------------------
                results : list
                    List of Results objects.
            --------------------------------------

            Methods:

                return_results(self):
                    Returns a list of results objects, sorted by
                    relevance value.
            
                search_campaign(self, campaign(obj), query(str)):
                    Searches the database for entries that match
                    the given search query, and creates Result
                    objects for each match. Appends them to
                    self.results.    
    """

    def __init__(self):
        self.results = []

    def return_results(self):
        return sorted(self.results, key=lambda result: result.relevance)

    def search_campaign(self, campaign, query):

        self.results = []
        query = query.lower()

        # Get the columns of the Event model, excluding irrelevant ones
        excluded_event_columns = [
            "id",
            "url_title",
            "year",
            "month",
            "day",
            "hour",
            "minute",
            "second",
            "header",
            "hide_time",
            "campaign_id",
            "following_event_id"
        ]

        excluded_epoch_columns = [
            "id",
            "url_title",
            "start_year",
            "start_month",
            "start_day",
            "end_year",
            "end_month",
            "end_day",
            "has_events",
            "campaign_id"
        ]

        event_columns = [func.lower(column).label(column.name) for column in models.Event.__table__.columns
                         if column.name not in excluded_event_columns]

        epoch_columns = [func.lower(column).label(column.name) for column in models.Epoch.__table__.columns
                         if column.name not in excluded_epoch_columns]

        # Construct .like statements for each column using given search query
        event_query_filter = or_(*[column.like(f"%{query}%") for column in event_columns])
        epoch_query_filter = or_(*[column.like(f"%{query}%") for column in epoch_columns])

        # Filter the Event model objects based on the query filter
        event_results = (db.session.query(models.Event)
                         .join(models.Campaign.events)
                         .filter(models.Campaign.id == campaign.id, event_query_filter)
                         .all())

        # Filter the Event model objects based on the query filter
        epoch_results = (db.session.query(models.Epoch)
                         .join(models.Campaign.epochs)
                         .filter(models.Campaign.id == campaign.id, epoch_query_filter)
                         .all())

        all_results = event_results + epoch_results

        # Create event Result objects
        for item in all_results:

            result = Result()
            result.object = item

            if isinstance(item, models.Event):
                result.type = "Event"
                result.url = url_for("event.view_event",
                                     campaign_name=campaign.url_title,
                                     campaign_id=campaign.id,
                                     event_name=item.url_title,
                                     event_id=item.id)

                result.edit_url = url_for("event.edit_event",
                                          campaign_name=campaign.url_title,
                                          campaign_id=campaign.id,
                                          event_name=item.url_title,
                                          event_id=item.id)

                table_columns = event_columns

            elif isinstance(item, models.Epoch):
                result.type = "Epoch"
                result.url = url_for("epoch.view_epoch",
                                     campaign_name=campaign.url_title,
                                     campaign_id=campaign.id,
                                     epoch_title=item.url_title,
                                     epoch_id=item.id)

                result.edit_url = url_for("epoch.edit_epoch",
                                          campaign_name=campaign.url_title,
                                          campaign_id=campaign.id,
                                          epoch_title=item.url_title,
                                          epoch_id=item.id)

                table_columns = epoch_columns

            scores = []

            # Find the matching event attributes
            for column in table_columns:
                attr_value = getattr(item, column.name)
                if query in str(attr_value).lower():

                    matching_words = []
                    result.matching_attributes.append(column.name)
                    result.excerpt = self.create_excerpt(item)

                    # Convert html value entries to plain text
                    html_columns = ["description", "overview"]
                    if column.name in html_columns:
                        soup = BeautifulSoup(attr_value, "html.parser")
                        value = soup.get_text()
                    else:
                        value = attr_value

                    for word in value.split(" "):
                        if query in word.lower():
                            matching_words.append(word)

                        relevance = editdistance.eval(query, word)
                        scores.append(relevance)

            # Calculate final relevance score
            result.relevance = (sum(scores) / len(scores)) / len(scores)

            # Create matching attributes text for template
            result.matching_attributes_text = ", ".join(result.matching_attributes).title()

            self.results.append(result)

    @staticmethod
    def create_excerpt(item):

        if isinstance(item, models.Event):
            excerpt_html = item.body
        elif isinstance(item, models.Epoch):
            excerpt_html = item.description or item.overview

        # Convert html to plaintext with BeautifulSoup
        if excerpt_html is not None:
            soup = BeautifulSoup(excerpt_html, "html.parser")
            plain_text = soup.get_text()

            # Ignore words within header tags
            for header in soup.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']):
                header_text = header.get_text()
                plain_text = plain_text.replace(header_text, "")

            excerpt = " ".join(plain_text.split()[:30])
            return f"{excerpt}..."
        else:
            return None
        